===== preprocess.py =====

import numpy as np  
from scipy.spatial.distance import cdist  
from pathlib import Path  
# from torch_geometric.data import Data  
# import torch  
from rdkit import Chem  
from pymol import cmd  
# 添加PLIP导入  
from plip.structure.preparation import PDBComplex  
import tempfile  
import os  
from plip_analysis import merge_protein_ligand_with_pymol  
from intra_pro_plip import (  
    InteractionAnalyzer,  
    AtomInfo, Config )
from water_metal_detection import detect_water_bridges_from_atoms, detect_metal_complex_from_atoms
from intra_lig_plip import InteractionAnalyzer as LigandInteractionAnalyzer
import time
from openbabel import pybel

# 扩展边特征编码  
SPATIAL_EDGE = [4, 0, 0]  # 原有空间边  
HYDROGEN_BOND_EDGE = [5, 1, 0]  # 氢键  
HYDROPHOBIC_EDGE = [5, 2, 0]    # 疏水相互作用  
PI_STACKING_EDGE = [5, 3, 0]    # π-π堆积  
PI_CATION_EDGE = [5, 4, 0]      # π-阳离子相互作用  
SALT_BRIDGE_EDGE = [5, 5, 0]    # 盐桥  
WATER_BRIDGE_EDGE = [5, 6, 0]   # 水桥  
HALOGEN_BOND_EDGE = [5, 7, 0]   # 卤键  
METAL_COMPLEX_EDGE = [5, 8, 0]  # 金属配位  
OTHERS_EDGE = [5, 9, 0]         # 其他相互作用  
  
# 相互作用类型映射  
INTERACTION_TYPE_MAP = {  
    'hydrogen_bonds': HYDROGEN_BOND_EDGE,        # 改为复数  
    'hydrophobic_contacts': HYDROPHOBIC_EDGE,    # 改为复数  
    'pi_stacking': PI_STACKING_EDGE,  
    'pi_cation': PI_CATION_EDGE,  
    'salt_bridges': SALT_BRIDGE_EDGE,            # 改为复数  
    'water_bridges': WATER_BRIDGE_EDGE,          # 改为复数  
    'halogen_bonds': HALOGEN_BOND_EDGE,          # 改为复数  
    'metal_complexes': METAL_COMPLEX_EDGE,       # 改为复数  
    'others': OTHERS_EDGE  
}

def analyze_plip_interactions(protein_file, ligand_file):  
    """  
    使用PLIP分析蛋白质-配体相互作用  
      
    Args:  
        protein_file: 蛋白质PDB文件路径  
        ligand_file: 配体SDF文件路径  
      
    Returns:  
        dict: 包含原子对相互作用信息的字典  
    """  
    # Create complex file in the same directory as the protein file  
    protein_path = Path(protein_file)  
    complex_file = protein_path.parent / "complex.pdb"  
      
     
    if not complex_file.exists():  
        # print(f"Creating complex file: {complex_file}")  
          
        if not merge_protein_ligand_with_pymol(protein_file, ligand_file, str(complex_file)):  
            print(f"Failed to create complex file")  
            return {}  
          
        # 新增：修改HETATM行的链标识符  
        fix_hetatm_chain_ids(str(complex_file), 'X')  
        
    try:  
        my_mol = PDBComplex()  
        my_mol.load_pdb(str(complex_file))
        # print(f"DEBUG: 识别出的配体数量: {len(my_mol.ligands)}")  
        # for i, ligand in enumerate(my_mol.ligands):  
        #     print(f"DEBUG: 配体 {i+1}: {ligand.hetid}, 链: {ligand.chain}, 位置: {ligand.position}")  
            # print(f"DEBUG: 配体类型: {ligand.type}, 长名称: {ligand.longname}")  

        # print(f"DEBUG: 排除的分子: {my_mol.excluded}") 
        my_mol.analyze()  
          
        # 提取原子对信息  
        atom_pairs_dict = {}  
        # print(f"DEBUG: 发现的结合位点标识符: {list(my_mol.interaction_sets.keys())}")  
        # print(f"DEBUG: 结合位点详细信息:")
        for bsid, interactions in my_mol.interaction_sets.items():  
            atom_pairs_dict[bsid] = {  
                'hydrogen_bonds': [],  
                'hydrophobic_contacts': [],  
                'pi_stacking': [],  
                'pi_cation': [],  
                'salt_bridges': [],  
                'water_bridges': [],  
                'halogen_bonds': [],  
                'metal_complexes': []  
            }  
              
            # 氢键  
            for hbond in interactions.hbonds_ldon + interactions.hbonds_pdon:  
                atom_pairs_dict[bsid]['hydrogen_bonds'].append({  
                    'protein_coords': hbond.d.coords if hbond.protisdon else hbond.a.coords,  
                    'ligand_coords': hbond.a.coords if hbond.protisdon else hbond.d.coords,  
                    'distance': hbond.distance_ad  
                })  
              
            # 疏水相互作用  
            for hydrophobic in interactions.hydrophobic_contacts:  
                atom_pairs_dict[bsid]['hydrophobic_contacts'].append({  
                    'protein_coords': hydrophobic.bsatom.coords,  
                    'ligand_coords': hydrophobic.ligatom.coords,  
                    'distance': hydrophobic.distance  
                })  
              
            # π-π堆积  
            for pistack in interactions.pistacking:  
                atom_pairs_dict[bsid]['pi_stacking'].append({  
                    'protein_coords': pistack.proteinring.center,  
                    'ligand_coords': pistack.ligandring.center,  
                    'distance': pistack.distance  
                })  
              
            # π-阳离子相互作用  
            for pication in interactions.pication_laro + interactions.pication_paro:  
                atom_pairs_dict[bsid]['pi_cation'].append({  
                    'protein_coords': pication.ring.center if pication.protcharged else pication.charge.center,  
                    'ligand_coords': pication.charge.center if pication.protcharged else pication.ring.center,  
                    'distance': pication.distance  
                })  
              
            # 盐桥  
            for saltbridge in interactions.saltbridge_lneg + interactions.saltbridge_pneg:  
                atom_pairs_dict[bsid]['salt_bridges'].append({  
                    'protein_coords': saltbridge.positive.center if saltbridge.protispos else saltbridge.negative.center,  
                    'ligand_coords': saltbridge.negative.center if saltbridge.protispos else saltbridge.positive.center,  
                    'distance': saltbridge.distance  
                })  
              
            # 水桥  
            for wbridge in interactions.water_bridges:  
                atom_pairs_dict[bsid]['water_bridges'].append({  
                    'protein_coords': wbridge.d.coords if wbridge.protisdon else wbridge.a.coords,  
                    'ligand_coords': wbridge.a.coords if wbridge.protisdon else wbridge.d.coords,  
                    'distance': (wbridge.distance_dw + wbridge.distance_aw) / 2  # 平均距离  
                })  
              
            # 卤键  
            for halogen in interactions.halogen_bonds:  
                atom_pairs_dict[bsid]['halogen_bonds'].append({  
                    'protein_coords': halogen.acc.coords,  
                    'ligand_coords': halogen.don.coords,  
                    'distance': halogen.distance  
                })  
              
            # 金属配位  
            for metal in interactions.metal_complexes:  
                atom_pairs_dict[bsid]['metal_complexes'].append({  
                    'protein_coords': metal.target.atom.coords,  
                    'ligand_coords': metal.metal.coords,  
                    'distance': metal.distance  
                })  
          
        return atom_pairs_dict  
          
    except Exception as e:  
        print(f"PLIP分析失败: {e}")  
        return {}  

def fix_hetatm_chain_ids(pdb_file, chain_id='X'):  
    """  
    修改PDB文件中HETATM行的链标识符  
      
    Args:  
        pdb_file: PDB文件路径  
        chain_id: 要设置的链标识符，默认为'X'  
    """  
    import os  
      
    # 读取原文件  
    with open(pdb_file, 'r') as f:  
        lines = f.readlines()  
      
    # 修改HETATM行  
    modified_lines = []  
    for line in lines:  
        if line.startswith('HETATM'):  
            # PDB格式：HETATM行的链标识符在第22位（索引21）  
            # 原格式：HETATM   48  H   UNK     0     105.436...  
            # 目标格式：HETATM   48  H   UNK X   0     105.436...  
            if len(line) > 21:  
                # 将第22位（索引21）设置为链标识符  
                line = line[:21] + chain_id + line[22:]  
            modified_lines.append(line)  
        else:  
            modified_lines.append(line)  
      
    # 写回文件  
    with open(pdb_file, 'w') as f:  
        f.writelines(modified_lines)  
      
    # print(f"✓ 已修改PDB文件中的HETATM链标识符为: {chain_id}")

def convert_plip_to_edges(atom_pairs_dict, lig_coord, pro_coord, lig_num_atom,   
                         lig_atom_id_map=None, pro_atom_id_map=None,   
                         lig_mol=None, pro_mol=None):  
    """  
    将PLIP相互作用转换为图边  
      
    Args:  
        atom_pairs_dict: PLIP分析结果  
        lig_coord: 配体原子坐标  
        pro_coord: 蛋白原子坐标  
        lig_num_atom: 配体原子数量  
        lig_atom_id_map: 配体原子ID到图索引的映射 (新增)  
        pro_atom_id_map: 蛋白原子ID到图索引的映射 (新增)  
        lig_mol: 配体分子对象 (新增)  
        pro_mol: 蛋白分子对象 (新增)  
      
    Returns:  
        tuple: (edge_index, edge_attr) 包含相互作用类型和距离的边  
    """  
    edge_list = []  
    edge_attr_list = []  
      
    for bsid, interactions in atom_pairs_dict.items():  
        for interaction_type, pairs in interactions.items():  
            if not pairs:  
                continue  
                  
            edge_type = INTERACTION_TYPE_MAP.get(interaction_type, OTHERS_EDGE)  
              
            for pair in pairs:  
                # 优先使用原子ID进行查找  
                lig_idx = None  
                pro_idx = None  
                  
                # 如果有原子ID信息，直接使用ID查找  
                if (lig_atom_id_map is not None and pro_atom_id_map is not None and   
                    'ligand_atom_id' in pair and 'protein_atom_id' in pair):  
                      
                    lig_atom_id = pair['ligand_atom_id']  
                    pro_atom_id = pair['protein_atom_id']  
                      
                    if lig_atom_id in lig_atom_id_map:  
                        lig_idx = lig_atom_id_map[lig_atom_id]  
                    if pro_atom_id in pro_atom_id_map:  
                        pro_idx = pro_atom_id_map[pro_atom_id]  
                  
                # 如果ID查找失败，回退到坐标查找  
                if lig_idx is None or pro_idx is None:  
                    lig_distances = cdist([pair['ligand_coords']], lig_coord)[0]  
                    pro_distances = cdist([pair['protein_coords']], pro_coord)[0]  
                      
                    lig_idx = np.argmin(lig_distances)  
                    pro_idx = np.argmin(pro_distances)  
                  
                # 实际欧氏距离  
                actual_distance = np.linalg.norm(  
                    np.array(pair['ligand_coords']) - np.array(pair['protein_coords'])  
                )  
                  
                # 创建边特征：[类型编码] + [欧氏距离]  
                edge_feature = edge_type + [actual_distance]  
                  
                # 添加双向边  
                edge_list.append([lig_idx, pro_idx + lig_num_atom])  
                edge_list.append([pro_idx + lig_num_atom, lig_idx])  
                edge_attr_list.append(edge_feature)  
                edge_attr_list.append(edge_feature)  
      
    if edge_list:  
        edge_index = np.array(edge_list, dtype=np.int64).T  
        edge_attr = np.array(edge_attr_list, dtype=np.float32)  
    else:  
        edge_index = np.empty((2, 0), dtype=np.int64)  
        edge_attr = np.empty((0, 4), dtype=np.float32)  
      
    return edge_index, edge_attr

def dim2(arr: np.ndarray):
    # 判断数组是否为二维
    return len(arr.shape) == 2

def reindex(atom_idx: list, edge_index: np.ndarray):
    # 对边的节点编号重新映射（因为去除部分原子后索引变化）
    if len(edge_index.shape) != 2:
        return edge_index
    indexmap = {old: new for new, old in enumerate(atom_idx)}
    mapfunc = np.vectorize(indexmap.get)
    edge_index_new = np.array([mapfunc(edge_index[0]), mapfunc(edge_index[1])])
    return edge_index_new

def remove_duplicated_edges(ei: np.ndarray, ea: np.ndarray, ref_ei: np.ndarray):
    # 删除和已有边重复的边（避免冗余）
    if not len(ea):
        return ei, ea
    existing_set = {(i, j) for i, j in zip(*ref_ei)}
    mask = []
    for i, j in zip(*ei):
        if (i, j) in existing_set:
            mask.append(False)  # 已有则删除
        else:
            mask.append(True)  # 否则保留
    mask = np.array(mask, dtype=bool)
    ei_n = np.array([ei[0][mask], ei[1][mask]])
    ea_n = ea[mask]
    return ei_n, ea_n


def gen_spatial_edge(dm: np.ndarray, spatial_cutoff: float = 5):
    """
    生成空间边，直接返回 4维特征 [4, 0, 0, distance]
    """
    if spatial_cutoff <= 0.1:
        return np.empty((2, 0), dtype=np.int64), np.empty((0, 4), dtype=np.float32)

    # 排除自身 (dm > 0.1) 和 超过阈值的
    src, dst = np.where((dm <= spatial_cutoff) & (dm > 0.1))
    
    if len(src) == 0:
        return np.empty((2, 0), dtype=np.int64), np.empty((0, 4), dtype=np.float32)

    edge_index = np.vstack([src, dst]).astype(np.int64)
    
    # 构建特征
    distances = dm[src, dst]
    # 构造 (N, 3) 的类型特征
    type_feats = np.tile(SPATIAL_EDGE, (len(src), 1))
    # 拼接距离变成 (N, 4)
    edge_attr = np.hstack([type_feats, distances.reshape(-1, 1)]).astype(np.float32)

    return edge_index, edge_attr

def gen_ligpro_edge(dm: np.ndarray, pocket_cutoff: float, plip_interactions=None,     
                   lig_coord=None, pro_coord=None, lig_atom_id_map=None, pro_atom_id_map=None):  
    """  
    生成配体-蛋白之间的边，混合策略：
    1. 优先生成 PLIP 相互作用边 (Type 5)
    2. 对剩余距离近的原子对生成空间边 (Type 4)
    """  
    lig_num_atom, pro_num_atom = dm.shape  
    all_edge_list = []  
    all_edge_attr_list = []  
      
    # --- 1. 生成 PLIP 相互作用边 (优先级最高) ---
    if plip_interactions and lig_coord is not None and pro_coord is not None:  
        plip_ei, plip_ea = convert_plip_to_edges(  
            plip_interactions, lig_coord, pro_coord, lig_num_atom,  
            lig_atom_id_map=lig_atom_id_map,     
            pro_atom_id_map=pro_atom_id_map    
        )  
        
        # 确保有边生成
        if plip_ei.shape[1] > 0:  
            # 转置为 list of tuples: [(u, v), ...]
            all_edge_list.extend(plip_ei.T.tolist())  
            all_edge_attr_list.extend(plip_ea.tolist())  
      
    # --- 2. 生成所有距离近的空间边 (作为候选) ---
    lig_idx, pro_idx = np.where(dm <= pocket_cutoff)  
      
    # 预先定义空间边的基础类型 [4, 0, 0]
    # 注意：这里假设 SPATIAL_EDGE 是全局变量，例如 [4, 0, 0]
    
    for x, y in zip(lig_idx, pro_idx):  
        distance = dm[x, y]  
        # 构造特征 [4, 0, 0, distance]
        edge_feature = SPATIAL_EDGE + [float(distance)]   
          
        # 添加双向边 (Ligand -> Protein) 和 (Protein -> Ligand)
        # 注意：这里必须和 convert_plip_to_edges 的节点索引逻辑保持一致
        # 通常 Ligand 索引是 0 ~ lig_n-1
        # Protein 索引是 lig_n ~ lig_n + pro_n - 1
        
        # L -> P
        all_edge_list.append((x, y + lig_num_atom))
        all_edge_attr_list.append(edge_feature)
        
        # P -> L
        all_edge_list.append((y + lig_num_atom, x))
        all_edge_attr_list.append(edge_feature)
      
    # --- 3. 去重逻辑 (核心) ---
    # 逻辑：因为 PLIP 边在列表前面，所以 set 会先记录 PLIP 边。
    # 当后续遍历到同坐标的空间边时，因为已在 set 中，会被忽略。
    
    if all_edge_list:  
        edge_set = set()  
        unique_edges = []  
        unique_attrs = []  
          
        for edge, attr in zip(all_edge_list, all_edge_attr_list):  
            # 将 list 转为 tuple 才能存入 set
            edge_tuple = tuple(edge)  
            
            if edge_tuple not in edge_set:  
                edge_set.add(edge_tuple)  
                unique_edges.append(edge)  
                unique_attrs.append(attr)  
          
        # 转换为 numpy 数组
        edge_index = np.array(unique_edges, dtype=np.int64).T  
        edge_attr = np.array(unique_attrs, dtype=np.float32)  
    else:  
        edge_index = np.empty((2, 0), dtype=np.int64)  
        # 注意：这里的 4 要根据你的特征维度决定，如果是 [type, sub, sub, dist] 则是 4
        edge_attr = np.empty((0, 4), dtype=np.float32)  
          
    return edge_index, edge_attr
 
  
def classify_protein_spatial_edges(pro_sei, pro_sea, pro_coord, protein_file,     
                                 pro_atom_ids=None, pro_atom_id_map=None):  
    import time  
    if len(pro_sei) == 0:  
        return pro_sei, pro_sea  
      
    try:    
        molecule = pybel.readfile("pdb", protein_file).__next__()  
        analyzer = InteractionAnalyzer()  
        analyzer.set_molecule(molecule)  
          
        # 方案1：预构建坐标到原子的哈希映射（高效且准确）  
        coord_to_atom_map = {}  
        tolerance = 0.01  # 0.01Å精度，更精确的匹配  
          
        for atom in molecule.atoms:  
            coord_key = tuple(np.round(atom.coords, 2))  # 保留2位小数精度  
            coord_to_atom_map[coord_key] = atom  
          
        def find_atom_by_coord_fast(coord):  
            coord_key = tuple(np.round(coord, 2))  
            return coord_to_atom_map.get(coord_key)  
          
        classified_edge_attr = []  
        successful_matches = 0  
        failed_matches = 0  
        interaction_detected = 0  
        total_edges = len(pro_sei.T)  
          
        t_big_loop = time.perf_counter()  
        for i, (src_idx, tgt_idx) in enumerate(pro_sei.T):  
            src_coord = pro_coord[src_idx]  
            tgt_coord = pro_coord[tgt_idx]  
            distance = np.linalg.norm(src_coord - tgt_coord)  
              
            # 使用快速坐标查找  
            src_ob_atom = find_atom_by_coord_fast(src_coord)  
            tgt_ob_atom = find_atom_by_coord_fast(tgt_coord)  
              
            src_atom = AtomInfo(src_ob_atom) if src_ob_atom else None  
            tgt_atom = AtomInfo(tgt_ob_atom) if tgt_ob_atom else None  
              
            if src_atom and tgt_atom:  
                successful_matches += 1  
                interaction_result = analyzer.analyze_atom_pair(src_atom, tgt_atom, distance)  
                  
                if interaction_result and interaction_result['interaction_types']:  
                    interaction_detected += 1  
                    interaction_type = interaction_result['interaction_types'][0]  
                      
                    # if interaction_detected <= 10:  
                    #     print(f"[DEBUG] 边 {i}: 检测到相互作用 {interaction_type}, 距离: {distance:.2f}Å")  
                      
                    if interaction_type == 'hydrogen_bond':  
                        edge_type_name = 'hydrogen_bonds'  
                    elif interaction_type == 'hydrophobic':  
                        edge_type_name = 'hydrophobic_contacts'  
                    elif interaction_type == 'salt_bridge':  
                        edge_type_name = 'salt_bridges'  
                    elif interaction_type == 'halogen_bond':  
                        edge_type_name = 'halogen_bonds'  
                    else:  
                        edge_type_name = 'others'  
                else:  
                    edge_type_name = check_ring_interactions_improved(  
                        src_atom, tgt_atom, distance, analyzer.rings, analyzer.charged_groups  
                    )  
                    if edge_type_name == 'others' and detect_water_bridges_from_atoms(src_atom, tgt_atom, distance, analyzer.molecule):  
                        edge_type_name = 'water_bridges'  
                    if edge_type_name == 'others' and detect_metal_complex_from_atoms(src_atom, tgt_atom, distance, analyzer.molecule):  
                        edge_type_name = 'metal_complexes'  
            else:  
                failed_matches += 1  
                edge_type_name = 'others'  
              
            edge_type = INTERACTION_TYPE_MAP.get(edge_type_name, OTHERS_EDGE)  
            edge_feature = edge_type + [distance]  
            classified_edge_attr.append(edge_feature)  
          
        # print(f"[DEBUG] 原子匹配统计:")  
        # print(f"  成功匹配: {successful_matches}/{total_edges} ({successful_matches/total_edges*100:.1f}%)")  
        # print(f"  匹配失败: {failed_matches}/{total_edges} ({failed_matches/total_edges*100:.1f}%)")  
        # print(f"  检测到特定相互作用: {interaction_detected}/{successful_matches} ({interaction_detected/successful_matches*100:.1f}% of successful matches)")  
          
        # print(f"[classify_protein_spatial_edges] total big loop time: {time.perf_counter() - t_big_loop:.3f}s")  
        classified_edge_attr = np.array(classified_edge_attr, dtype=np.float32)  
          
    except Exception as e:  
        print(f"使用 intra_pro_plip 分析失败: {e}")  
        classified_edge_attr = []  
        for i, (src_idx, tgt_idx) in enumerate(pro_sei.T):  
            distance = np.linalg.norm(pro_coord[src_idx] - pro_coord[tgt_idx])  
            edge_feature = OTHERS_EDGE + [distance]  
            classified_edge_attr.append(edge_feature)  
        classified_edge_attr = np.array(classified_edge_attr, dtype=np.float32)  
      
    return pro_sei, classified_edge_attr

def classify_ligand_spatial_edges(lig_sei, lig_sea, lig_coord, ligand_file,    
                                lig_atom_ids=None, lig_atom_id_map=None):    
    """    
    为配体内部空间边分配相互作用类型    
    """    
    if len(lig_sei) == 0:    
        return lig_sei, lig_sea    
        
    try:     
            
        # 使用OpenBabel加载配体结构    
        molecule = pybel.readfile("sdf", ligand_file).__next__()    
            
        # 创建并设置分子，使用精细检测函数    
        analyzer = LigandInteractionAnalyzer()    
        analyzer.set_molecule(molecule)  # 预计算所有功能基团    
          
        # 方案1：预构建坐标到原子的哈希映射（高效且准确）  
        coord_to_atom_map = {}  
          
        for atom in molecule.atoms:  
            coord_key = tuple(np.round(atom.coords, 2))  # 保留2位小数精度  
            coord_to_atom_map[coord_key] = atom  
          
        def find_atom_by_coord_fast(coord):  
            coord_key = tuple(np.round(coord, 2))  
            return coord_to_atom_map.get(coord_key)  
            
        # 为每条空间边分配类型    
        classified_edge_attr = []  
        successful_matches = 0  
        failed_matches = 0  
        interaction_detected = 0  
        total_edges = len(lig_sei.T)  
            
        for i, (src_idx, tgt_idx) in enumerate(lig_sei.T):    
            src_coord = lig_coord[src_idx]    
            tgt_coord = lig_coord[tgt_idx]    
            distance = np.linalg.norm(src_coord - tgt_coord)    
                
            # 使用快速坐标查找  
            src_ob_atom = find_atom_by_coord_fast(src_coord)  
            tgt_ob_atom = find_atom_by_coord_fast(tgt_coord)  
              
            src_atom = src_ob_atom if src_ob_atom else None  
            tgt_atom = tgt_ob_atom if tgt_ob_atom else None  
                
            if src_atom and tgt_atom:  
                successful_matches += 1  
                # 使用精细的LigandInteractionAnalyzer分析原子对    
                interaction_result = analyzer.analyze_atom_pair(src_atom, tgt_atom, distance)    
                    
                if interaction_result and interaction_result['interaction_types']:  
                    interaction_detected += 1  
                    # 取第一个检测到的相互作用类型    
                    interaction_type = interaction_result['interaction_types'][0]    
                      
                    # if interaction_detected <= 10:  
                        # print(f"[DEBUG] 配体边 {i}: 检测到相互作用 {interaction_type}, 距离: {distance:.2f}Å")  
                        
                    # 映射到标准类型名称    
                    if interaction_type == 'hydrogen_bond':    
                        edge_type_name = 'hydrogen_bonds'    
                    elif interaction_type == 'hydrophobic':    
                        edge_type_name = 'hydrophobic_contacts'    
                    elif interaction_type == 'salt_bridge':    
                        edge_type_name = 'salt_bridges'    
                    elif interaction_type == 'halogen_bond':    
                        edge_type_name = 'halogen_bonds'    
                    else:    
                        edge_type_name = 'others'    
                else:    
                    # 检查π-π堆积和π-阳离子相互作用，使用预计算的功能基团    
                    edge_type_name = check_ring_interactions_improved(    
                        src_atom, tgt_atom, distance,     
                        analyzer.rings, analyzer.charged_groups    
                    )    
                        
                    # 检查水桥相互作用    
                    if edge_type_name == 'others' and detect_water_bridges_from_atoms(src_atom, tgt_atom, distance, molecule):    
                        edge_type_name = 'water_bridges'    
                        
                    # 检查金属配位相互作用    
                    if edge_type_name == 'others' and detect_metal_complex_from_atoms(src_atom, tgt_atom, distance, molecule):    
                        edge_type_name = 'metal_complexes'    
            else:  
                failed_matches += 1  
                edge_type_name = 'others'    
                
            # 获取边类型编码 - 使用当前文件中已定义的常量    
            INTERACTION_TYPE_MAP = {    
                'hydrogen_bonds': HYDROGEN_BOND_EDGE,    
                'hydrophobic_contacts': HYDROPHOBIC_EDGE,    
                'pi_stacking': PI_STACKING_EDGE,    
                'pi_cation': PI_CATION_EDGE,    
                'salt_bridges': SALT_BRIDGE_EDGE,    
                'water_bridges': WATER_BRIDGE_EDGE,    
                'halogen_bonds': HALOGEN_BOND_EDGE,    
                'metal_complexes': METAL_COMPLEX_EDGE,    
                'others': OTHERS_EDGE    
            }    
                
            edge_type = INTERACTION_TYPE_MAP.get(edge_type_name, OTHERS_EDGE)    
                
            # 创建边特征：[类型编码] + [距离]    
            edge_feature = edge_type + [distance]    
            classified_edge_attr.append(edge_feature)  
          
        # 添加统计信息  
        # print(f"[DEBUG] 配体原子匹配统计:")  
        # print(f"  成功匹配: {successful_matches}/{total_edges} ({successful_matches/total_edges*100:.1f}%)")  
        # print(f"  匹配失败: {failed_matches}/{total_edges} ({failed_matches/total_edges*100:.1f}%)")  
        # print(f"  检测到特定相互作用: {interaction_detected}/{successful_matches} ({interaction_detected/successful_matches*100:.1f}% of successful matches)")  
            
        classified_edge_attr = np.array(classified_edge_attr, dtype=np.float32)    
            
    except Exception as e:    
        print(f"配体相互作用分析失败: {e}")    
        # 如果分析失败，将所有边设置为OTHERS类型    
        classified_edge_attr = []    
        for i, (src_idx, tgt_idx) in enumerate(lig_sei.T):    
            distance = np.linalg.norm(lig_coord[src_idx] - lig_coord[tgt_idx])    
            edge_feature = OTHERS_EDGE + [distance]    
            classified_edge_attr.append(edge_feature)    
        classified_edge_attr = np.array(classified_edge_attr, dtype=np.float32)    
        
    return lig_sei, classified_edge_attr

  
def check_ring_interactions_improved(src_atom, tgt_atom, distance, rings, charged_groups):  
    """改进的环相互作用检测，使用PLIP的精细检测函数"""  
    from intra_pro_plip import pistacking, pication  
      
    # 找到包含这两个原子的环  
    src_rings = []  
    tgt_rings = []  
      
    for ring in rings:  
        if any(ring_atom.idx == src_atom.idx for ring_atom in ring.atoms):  
            src_rings.append(ring)  
        if any(ring_atom.idx == tgt_atom.idx for ring_atom in ring.atoms):  
            tgt_rings.append(ring)  
      
    # 使用PLIP的精细π-π堆积检测  
    if src_rings and tgt_rings:  
        pi_stack_results = pistacking(src_rings, tgt_rings)  
        if pi_stack_results:  
            return 'pi_stacking'  
      
    # 使用PLIP的精细π-阳离子检测  
    if distance < 6.0:  # PICATION_DIST_MAX  
        # 检查是否有环-电荷组合  
        for ring in src_rings + tgt_rings:  
            for charge_group in charged_groups:  
                if charge_group.type == 'positive':  
                    pi_cation_results = pication([ring], [charge_group])  
                    if pi_cation_results:  
                        return 'pi_cation'  
      
    return 'others'

# def set_ligand_spatial_edge_types(lig_sea):  
#     """  
#     将配体内部空间边的类型统一设置为OTHERS_EDGE  
      
#     Args:  
#         lig_sea: 配体空间边属性  
      
#     Returns:  
#         np.array: 更新后的边属性  
#     """  
#     if len(lig_sea) == 0:  
#         return lig_sea  
      
#     # 为每条边设置OTHERS类型  
#     updated_edge_attr = []  
      
#     for edge_attr in lig_sea:  
#         # 保留原有的距离信息（如果存在）  
#         if len(edge_attr) > 3:  
#             distance = edge_attr[3]  
#         else:  
#             distance = edge_attr[-1] if len(edge_attr) > 0 else 0.0  
          
#         # 创建新的边特征：OTHERS_EDGE + 距离  
#         new_edge_feature = OTHERS_EDGE + [distance]  
#         updated_edge_attr.append(new_edge_feature)  
      
#     return np.array(updated_edge_attr, dtype=np.float32)

def gen_graph(ligand: tuple, pocket: tuple, name: str, protein_cutoff: float,     
              pocket_cutoff: float, spatial_cutoff: float, protein_file=None,     
              ligand_file=None, plip_interactions=None,  
              ligand_dict=None, pocket_dict=None):  # 新增参数   
    # 构建复合物的整体图结构（节点、特征、边、空间边）  
  
    # 解包配体和蛋白 pocket 的输入：坐标、特征、边索引、边特征  
    lig_coord, lig_feat, lig_ei, lig_ea = ligand  
    pro_coord, pro_feat, pro_ei, pro_ea = pocket  
  
    # 检查配体和蛋白的坐标和特征长度是否一致  
    assert len(lig_coord) == len(lig_feat)  
    assert len(pro_coord) == len(pro_feat)  
  
    # 检查 cutoff 参数的合理性  
    assert protein_cutoff >= pocket_cutoff, f"Protein cutoff {protein_cutoff} should be larger than pocket cutoff {pocket_cutoff}"  
    assert pocket_cutoff >= spatial_cutoff, f"Pocket cutoff {pocket_cutoff} should be larger than spatial cutoff {spatial_cutoff}"  
  
    # 如果没有提供PLIP分析结果且有文件路径，进行PLIP分析  
    if plip_interactions is None and protein_file and ligand_file:  
        plip_interactions = analyze_plip_interactions(protein_file, ligand_file)  
    # 只保留距离配体小于 protein_cutoff 的蛋白原子
    # 先初始化全为 False 的掩码
    pro_atom_mask = np.zeros(len(pro_coord), dtype=bool)
    # 计算配体和蛋白的距离矩阵，保留距离小于 protein_cutoff 的蛋白原子的索引
    pro_atom_mask[np.where(cdist(lig_coord, pro_coord) <= protein_cutoff)[1]] = 1
    # 只保留蛋白内部边的两端都在掩码范围内的边
    pro_edge_mask = np.array([True if pro_atom_mask[i] and pro_atom_mask[j] else False for i, j in zip(*pro_ei)])

    # 筛选对应的蛋白节点和边
    pro_coord = pro_coord[pro_atom_mask]   # 只保留掩码内的坐标
    pro_feat = pro_feat[pro_atom_mask]     # 只保留掩码内的特征
    # 只保留掩码内的边
    pro_ei = np.array([pro_ei[0, pro_edge_mask], pro_ei[1, pro_edge_mask]])
    pro_ea = pro_ea[pro_edge_mask]
    # 边的原子索引需要重新编号（因为节点删减了）
    pro_ei = reindex(np.where(pro_atom_mask)[0], pro_ei)
    lig_sei = np.empty((2, 0), dtype=np.int64)  
    lig_sea = np.empty((0, 4), dtype=np.float32)
    pro_sei = np.empty((2, 0), dtype=np.int64)  
    pro_sea = np.empty((0, 4), dtype=np.float32)
    # 配体内部空间边：所有距离小于 spatial_cutoff 的配体原子对
    lig_dm = cdist(lig_coord, lig_coord)   # 配体原子之间的距离矩阵
    lig_atom_ids = ligand_dict.get('atom_ids') if ligand_dict else None  
    lig_atom_id_map = ligand_dict.get('atom_id_to_graph_index') if ligand_dict else None  
    pro_atom_ids = pocket_dict.get('atom_ids') if pocket_dict else None  
    pro_atom_id_map = pocket_dict.get('atom_id_to_graph_index') if pocket_dict else None 
    lig_sei, lig_sea = gen_spatial_edge(lig_dm, spatial_cutoff=spatial_cutoff)  # 生成空间边
    lig_sei, lig_sea = remove_duplicated_edges(lig_sei, lig_sea, lig_ei)        # 去掉和结构边重复的空间边
    lig_sei, lig_sea = classify_ligand_spatial_edges(  
        lig_sei, lig_sea, lig_coord, ligand_file,  
        lig_atom_ids=lig_atom_ids, lig_atom_id_map=lig_atom_id_map  
    ) 
    # 蛋白内部空间边：所有距离小于 spatial_cutoff 的蛋白原子对
    pro_dm = cdist(pro_coord, pro_coord)  
    pro_sei, pro_sea = gen_spatial_edge(pro_dm, spatial_cutoff=spatial_cutoff)  
    pro_sei, pro_sea = remove_duplicated_edges(pro_sei, pro_sea, pro_ei)
    pro_sei, pro_sea = classify_protein_spatial_edges(  
        pro_sei, pro_sea, pro_coord, protein_file,  
        pro_atom_ids=pro_atom_ids, pro_atom_id_map=pro_atom_id_map  
    )  
    # 新增：使用更新的 intra_pro_plip 脚本进行类型分类  
    
    # 配体-蛋白之间的空间边：所有距离小于 pocket_cutoff 的配体-蛋白原子对
    dm_lig_pro = cdist(lig_coord, pro_coord)  
    lig_pock_ei, lig_pock_ea = gen_ligpro_edge(  
        dm_lig_pro,  
        pocket_cutoff=pocket_cutoff,  
        plip_interactions=plip_interactions,  
        lig_coord=lig_coord,  
        pro_coord=pro_coord,  
        lig_atom_id_map=lig_atom_id_map,  # 新增  
        pro_atom_id_map=pro_atom_id_map   # 新增  
    ) 
    def pad_edge_features_with_distance(edge_attr, edge_index, coords):  
        """为3维边特征添加距离信息，使其变为4维"""  
        if edge_attr.shape[1] == 3:  # 如果是3维特征  
            distances = []  
            for i in range(edge_index.shape[1]):  
                src_idx, dst_idx = edge_index[0, i], edge_index[1, i]  
                dist = np.linalg.norm(coords[src_idx] - coords[dst_idx])  
                distances.append(dist)  

            # 添加距离作为第4维  
            distances = np.array(distances).reshape(-1, 1)  
            edge_attr = np.hstack([edge_attr, distances]).astype(np.float32)  

        return edge_attr  
  
# 在拼接前处理所有边特征  
    lig_ea = pad_edge_features_with_distance(lig_ea, lig_ei, lig_coord)  
    pro_ea = pad_edge_features_with_distance(pro_ea, pro_ei, pro_coord)
    # 构建整体节点、特征
    comp_coord = np.vstack([lig_coord, pro_coord])   # 合并配体和蛋白的原子坐标
    comp_feat = np.vstack([lig_feat, pro_feat])      # 合并配体和蛋白的原子特征
    comp_ei, comp_ea = lig_ei, lig_ea                # 先只用配体的结构边作为初始边
    # print(f"lig_ea shape: {lig_ea.shape}")  
    # print(f"pro_ea shape: {pro_ea.shape}")  
    # print(f"lig_sea shape: {lig_sea.shape}")  
    # print(f"pro_sea shape: {pro_sea.shape}")  
    # print(f"lig_pock_ea shape: {lig_pock_ea.shape}")

    # 拼接所有蛋白、配体、空间和配体-蛋白边
    if len(pro_ei.shape) == 2 and len(pro_ei.T) >= 3:   # 如果蛋白有结构边
        comp_ei = np.hstack([comp_ei, pro_ei + len(lig_feat)])   # 蛋白边下标整体平移
        comp_ea = np.vstack([comp_ea, pro_ea])                  # 合并蛋白边特征
    if len(lig_sei.shape) == 2 and len(lig_sei.T) >= 3:         # 如果配体有空间边
        comp_ei = np.hstack([comp_ei, lig_sei])                 # 合并配体空间边
        comp_ea = np.vstack([comp_ea, lig_sea])                 # 合并配体空间边特征
    if len(pro_sei.shape) == 2 and len(pro_sei.T) >= 3:         # 如果蛋白有空间边
        comp_ei = np.hstack([comp_ei, pro_sei + len(lig_feat)]) # 蛋白空间边下标整体平移
        comp_ea = np.vstack([comp_ea, pro_sea])                 # 合并蛋白空间边特征
    if len(lig_pock_ei.shape) == 2 and len(lig_pock_ei.T) >= 3: # 如果有配体-蛋白空间边
        comp_ei = np.hstack([comp_ei, lig_pock_ei])             # 合并配体-蛋白空间边
        comp_ea = np.vstack([comp_ea, lig_pock_ea])             # 合并配体-蛋白空间边特征

    # 记录每类节点、边数
    comp_num_node = np.array([len(lig_feat), len(pro_feat)], dtype=np.int64)   # 配体、蛋白节点数
    comp_num_edge = np.array([  
    lig_ei.shape[1],           # 配体结构边数  
    pro_ei.shape[1],           # 蛋白结构边数  
    lig_pock_ei.shape[1],      # 配体-蛋白边数  
    lig_sei.shape[1],          # 配体空间边数
    pro_sei.shape[1],          # 蛋白空间边数
], dtype=np.int64)
    return comp_coord, comp_feat, comp_ei, comp_ea, comp_num_node, comp_num_edge, lig_sei, lig_sea, pro_sei, pro_sea

def load_pk_data(data_path: Path):
    # 从txt读取pdbid与pk值
    pdbid, pk = [], []
    for line in open(data_path):
        if line[0] == '#': continue
        elem = line.split()
        v1, _, _, v2 = elem[:4]
        pdbid.append(v1)
        pk.append(float(v2))
    res = {i: p for i, p in zip(pdbid, pk)}
    return res

# def to_pyg_graph(raw: list, **kwargs):  
#     comp_coord, comp_feat, comp_ei, comp_ea, comp_num_node, comp_num_edge, rfscore, gbscore, ecif, pk, name = raw  
      
#     # 从kwargs中提取rmsd值  
#     rmsd = kwargs.pop('rmsd', 0.0)  # 默认值为0.0  
  
#     d = Data(x=torch.from_numpy(comp_feat).to(torch.long),     
#          edge_index=torch.from_numpy(comp_ei).to(torch.long),     
#          edge_attr=torch.from_numpy(comp_ea).to(torch.float32),  # 改为float32  
#          pos=torch.from_numpy(comp_coord).to(torch.float32),
#      y=torch.tensor([pk], dtype=torch.float32),   
#      pdbid=name,  
#      num_node=torch.from_numpy(comp_num_node).to(torch.long),   
#      num_edge=torch.from_numpy(comp_num_edge).to(torch.long),  
#      rfscore=torch.from_numpy(rfscore).to(torch.float32),   
#      gbscore=torch.from_numpy(gbscore).to(torch.float32),  
#      ecif=torch.from_numpy(ecif).to(dtype=torch.float32),  
#      rmsd=torch.tensor([rmsd], dtype=torch.float32),  # 新增：rmsd值  
#      **kwargs)  
#     return d

def get_info(protein_file, ligand_file):
    # 用PyMOL获取蛋白和配体的元素、残基和坐标信息
    cmd.reinitialize()
    cmd.load(protein_file, 'receptor')
    cmd.load(ligand_file, 'ligand')
    cmd.remove('sol.')
    cmd.h_add()
    proinfo = {"elem": [], "resn": [], "coord":[], }
    liginfo = {"elem": [], "resn": [], "coord":[], }
    cmd.iterate_state(1, 'receptor', 'info["elem"].append(elem); info["resn"].append(resn); info["coord"].append(np.array([x, y, z]))',space={"info": proinfo, "np": np})
    cmd.iterate_state(1, 'ligand', 'info["elem"].append(elem); info["resn"].append(resn); info["coord"].append(np.array([x, y, z]))',space={"info": liginfo, "np": np})
    for k in proinfo.keys():
        proinfo[k] = np.array(proinfo[k])
        liginfo[k] = np.array(liginfo[k])
    return proinfo, liginfo

def GB_score(lig_info: dict, pro_info: dict) -> np.ndarray:
    # 生成GBScore特征（配体-蛋白原子对分组距离统计，400维）
    amino_acid_groups = [
        {"ARG", "LYS", "ASP", "GLU"},
        {"GLN", "ASN", "HIS", "SER", "THR", "CYS"},
        {"TRP", "TYR", "MET"},
        {"ILE", "LEU", "PHE", "VAL", "PRO", "GLY", "ALA"},
    ]
    elements = ["H", "C", "N", "O", "S", "P", "F", "Cl", "Br", "I"]
    distmap = cdist(lig_info['coord'], pro_info['coord'])
    restype = np.zeros(len(pro_info['resn'])) - 1
    elem_mask = {k: pro_info["elem"] == k for k in elements}
    fp = np.zeros([len(elements), len(elements), len(amino_acid_groups)])

    for idx, r in enumerate(pro_info['resn']):
        if r in amino_acid_groups[0]: restype[idx] = 0
        if r in amino_acid_groups[1]: restype[idx] = 1
        if r in amino_acid_groups[2]: restype[idx] = 2
        if r in amino_acid_groups[3]: restype[idx] = 3

    for i, el in enumerate(elements):
        lmask = lig_info["elem"] == el
        if lmask.sum() < 1: continue
        for j, ep in enumerate(elements):
            pmask = elem_mask[ep]
            if pmask.sum() < 1: continue
            for k, rt in enumerate(range(4)):
                rt_mask = restype == rt
                m = pmask & rt_mask
                if m.sum() < 1: continue
                d = distmap[lmask][:, m]
                v = (1 / d[d<=12]).sum()
                fp[i, j, k] = v

    return fp.flatten()



===== custom_input.py =====
#!/usr/bin/env python3
import argparse
from pathlib import Path
import pickle
from preprocess import gen_graph, get_info, GB_score, analyze_plip_interactions
from joblib import Parallel, delayed
from utils import read_mol, pymol_pocket
import numpy as np
from rdkit import RDLogger
from rdkit import Chem
import pandas as pd
from mol2graph import mol2graph_ligand, mol2graph_protein_from_pdb
import time

def parallel_helper(proteinpdb, ligand_file, name, pk, rmsd, protein_cutoff, pocket_cutoff, spatial_cutoff):
    """
    处理单个蛋白质-配体复合物的并行辅助函数
    支持ligand.pdb或ligand.sdf输入
    """
    RDLogger.DisableLog('rdApp.*')
    
    if not (proteinpdb.is_file() and ligand_file.is_file()):
        print(f"{proteinpdb} or {ligand_file} does not exist.")
        return None
    
    # 生成口袋PDB文件（如果不存在）
    pocketpdb = proteinpdb.parent / (name + '_protein_pocket.pdb')
    if not pocketpdb.is_file():
        pymol_pocket(proteinpdb, ligand_file, pocketpdb)
    
    try:
        # 根据文件扩展名选择处理方式
        ligand_suffix = ligand_file.suffix.lower()
        
        if ligand_suffix == '.pdb':
            # 使用mol2graph_protein_from_pdb处理PDB格式配体
            print(f"检测到PDB格式配体: {ligand_file}")
            ligand_dict = mol2graph_protein_from_pdb(ligand_file)
            
            # 尝试从PDB生成SMILES(可选,可能失败)
            try:
                ligand_mol = Chem.MolFromPDBFile(str(ligand_file), removeHs=False)
                if ligand_mol:
                    ligand_dict['smiles'] = Chem.MolToSmiles(ligand_mol)
                else:
                    ligand_dict['smiles'] = 'N/A'
            except:
                ligand_dict['smiles'] = 'N/A'
                
        elif ligand_suffix in ['.sdf', '.mol', '.mol2']:
            # 使用mol2graph_ligand处理SDF格式配体(原有逻辑)
            print(f"检测到SDF格式配体: {ligand_file}")
            ligand = read_mol(ligand_file)
            ligand_dict = mol2graph_ligand(ligand)
        else:
            raise ValueError(f"不支持的配体文件格式: {ligand_suffix}")
        
        # 使用口袋PDB而不是完整蛋白质
        pocket_dict = mol2graph_protein_from_pdb(pocketpdb)
        
        proinfo, liginfo = get_info(proteinpdb, ligand_file)
        
        res = {
            'lc': ligand_dict['coords'], 'lf': ligand_dict['node_feat'],
            'lei': ligand_dict['edge_index'], 'lea': ligand_dict['edge_feat'],
            'pc': pocket_dict['coords'], 'pf': pocket_dict['node_feat'],
            'pei': pocket_dict['edge_index'], 'pea': pocket_dict['edge_feat'],
            'pdbid': name,
            'ligand_smiles': ligand_dict.get('smiles', 'N/A'),
            'protein_atom_names': pocket_dict['pro_name'],
            'protein_aa_names': pocket_dict['AA_name']
        }
        
        res['gbscore'] = GB_score(liginfo, proinfo)
        
        # PLIP相互作用分析
        plip_interactions = analyze_plip_interactions(str(proteinpdb), str(ligand_file))
        if plip_interactions:
            print(f"发现的结合位点数: {len(plip_interactions)}")
        res['plip_interactions'] = plip_interactions
        
    except RuntimeError as e:
        print(f"{proteinpdb}, {pocketpdb}, {ligand_file}: 读取分子失败 - {e}")
        return None
    except ValueError as e:
        print(f"{name}: {e}")
        return None
    
    ligand = (res['lc'], res['lf'], res['lei'], res['lea'])
    pocket = (res['pc'], res['pf'], res['pei'], res['pea'])
    
    try:
        raw = gen_graph(
            ligand, pocket, name,
            protein_cutoff=protein_cutoff,
            pocket_cutoff=pocket_cutoff,
            spatial_cutoff=spatial_cutoff,
            protein_file=str(proteinpdb),
            ligand_file=str(ligand_file),
            plip_interactions=res['plip_interactions'],
            ligand_dict=ligand_dict,
            pocket_dict=pocket_dict
        )
        
        comp_coord, comp_feat, comp_ei, comp_ea, comp_num_node, comp_num_edge, lig_sei, lig_sea, pro_sei, pro_sea = raw
    except ValueError as e:
        print(f"{name}: gen_graph错误 - {str(e)}")
        return None
    
    # 返回字典格式
    result_dict = {
        'edge_index': comp_ei, 'edge_feat': comp_ea, 'node_feat': comp_feat, 'coords': comp_coord,
        'pro_name': res['protein_atom_names'], 'AA_name': res['protein_aa_names'],
        'smiles': res['ligand_smiles'], 'rmsd': rmsd,
        'gbscore': res['gbscore'],
        'pk': pk, 'pdbid': name, 'num_node': comp_num_node, 'num_edge': comp_num_edge,
        'lig_spatial_edge_index': lig_sei,
        'lig_spatial_edge_attr': lig_sea,
        'pro_spatial_edge_index': pro_sei + len(comp_feat) // 2,
        'pro_spatial_edge_attr': pro_sea
    }
    
    return result_dict

if __name__ == "__main__":
    start_time = time.time()
    
    parser = argparse.ArgumentParser()
    parser.add_argument('file_csv', type=Path, help='输入CSV文件')
    parser.add_argument('output', type=Path, help='输出PKL文件路径')
    parser.add_argument('--njobs', type=int, default=1)
    parser.add_argument('--protein_cutoff', type=float, default=6.)
    parser.add_argument('--pocket_cutoff', type=float, default=5.)
    parser.add_argument('--spatial_cutoff', type=float, default=5.)
    args = parser.parse_args()
    
    # 读取CSV文件
    filedf = pd.read_csv(args.file_csv)
    receptors = filedf['receptor']
    ligands = filedf['ligand']
    names = filedf['name']
    pks = filedf['pk']
    rmsds = filedf['rmsd']
    
    # 并行处理
    graph_dicts = Parallel(n_jobs=args.njobs)(
        delayed(parallel_helper)(
            Path(rec), Path(lig), name, pk, rmsd,
            args.protein_cutoff, args.pocket_cutoff, args.spatial_cutoff
        )
        for rec, lig, name, pk, rmsd in zip(receptors, ligands, names, pks, rmsds)
    )
    
    # 过滤掉None结果
    graph_dicts = list(filter(None, graph_dicts))
    
    # 创建输出目录（如果不存在）
    args.output.parent.mkdir(parents=True, exist_ok=True)
    
    # 保存为PKL文件
    with open(args.output, 'wb') as f:
        pickle.dump(graph_dicts, f)
    
    elapsed = time.time() - start_time
    print(f"[custom_input.py] 完成,耗时 {elapsed:.2f} 秒")
    print(f"已保存 {len(graph_dicts)} 个复合物到 {args.output}")

===== intra_lig_plip.py =====
#!/usr/bin/env python3    
"""    
配体内部相互作用分析模块    
直接复用 intra_pro_plip.py 的所有类和函数定义，适配配体分子    
"""    
    
import numpy as np    
from openbabel import pybel    
from typing import List, Dict, Tuple, Optional, Set    
import math  
import itertools  
from collections import namedtuple  
  
# 导入 intra_pro_plip.py 中的精细检测函数和辅助函数  
from intra_pro_plip import (  
    hydrophobic_interactions, hbonds, pistacking,   
    saltbridge, pication, halogen_bonds,  
    euclidean3d, vector, vecangle, normalize_vector,  
    AtomInfo as ProAtomInfo, RingInfo as ProRingInfo  
)  
  
class AtomInfo:    
    """原子信息类，存储原子的基本属性 - 兼容 intra_pro_plip.py"""    
    def __init__(self, atom):    
        self.atom = atom    
        self.idx = atom.idx    
        self.atomicnum = atom.atomicnum    
        self.coords = np.array([atom.coords[0], atom.coords[1], atom.coords[2]])    
        self.element = atom.OBAtom.GetAtomicNum()    
        self.formal_charge = getattr(atom, 'formalcharge', 0)
        self.partial_charge = getattr(atom.OBAtom, 'GetPartialCharge', lambda: 0.0)()  
        self.type = atom.type  
        self.OBAtom = atom.OBAtom  
  
class Config:    
    """配置参数类 - 与 intra_pro_plip.py 保持一致"""    
    HYDROPHOBIC_DIST_MAX = 4.0  
    HYDROPH_DIST_MAX = 4.0  # 别名，与 intra_pro_plip.py 兼容  
    HBOND_DIST_MAX = 3.5    
    HBOND_DON_ANGLE_MIN = 120.0    
    PISTACK_DIST_MAX = 5.5    
    PISTACK_ANG_DEV = 30.0    
    PISTACK_OFFSET_MAX = 2.0    
    PICATION_DIST_MAX = 6.0    
    SALTBRIDGE_DIST_MAX = 5.0    
    HALOGEN_DIST_MAX = 4.0    
    HALOGEN_ACC_ANGLE = 120.0    
    HALOGEN_DON_ANGLE = 165.0  
    HALOGEN_ANGLE_DEV = 30.0  # 新增角度偏差参数  
    WATER_BRIDGE_MINDIST = 2.5    
    WATER_BRIDGE_MAXDIST = 4.0    
    METAL_DIST_MAX = 3.0  
    MIN_DIST = 0.5  # 最小距离阈值  
  
# 全局配置实例  
config = Config()  
  
def find_hydrophobic_atoms(molecule):    
    """识别疏水原子 - 返回 AtomInfo 对象列表，兼容 intra_pro_plip.py"""    
    hydrophobic_atoms = []    
        
    for atom in molecule.atoms:    
        if atom.atomicnum == 6:  # Carbon    
            # 检查邻居原子是否只有碳和氢    
            neighbor_nums = set()    
            for neighbor in pybel.ob.OBAtomAtomIter(atom.OBAtom):    
                neighbor_nums.add(neighbor.GetAtomicNum())    
                
            # 如果邻居只有碳(6)和氢(1)，则为疏水原子    
            if neighbor_nums.issubset({1, 6}):    
                hydrophobic_atoms.append(AtomInfo(atom))    
        elif atom.atomicnum == 16:  # Sulfur    
            hydrophobic_atoms.append(AtomInfo(atom))    
        
    return hydrophobic_atoms    
  
def find_hba(molecule):    
    """识别氢键受体 - 返回 AtomInfo 对象列表，兼容 intra_pro_plip.py"""    
    acceptors = []    
        
    for atom in molecule.atoms:    
        # 排除卤素原子    
        if atom.atomicnum not in [9, 17, 35, 53]:    
            if atom.OBAtom.IsHbondAcceptor():    
                acceptors.append(AtomInfo(atom))    
        
    return acceptors    
  
def find_hbd(molecule, hydrophobic_atoms=None):    
    """识别氢键供体 - 返回 namedtuple 对象列表，兼容 intra_pro_plip.py"""    
    data = namedtuple('hbonddonor', 'd h type')    
    donors = []    
        
    # 强氢键供体    
    for atom in molecule.atoms:    
        if atom.OBAtom.IsHbondDonor():    
            for adj_atom in pybel.ob.OBAtomAtomIter(atom.OBAtom):    
                if adj_atom.IsHbondDonorH():    
                    donors.append(data(d=AtomInfo(atom), h=pybel.Atom(adj_atom), type='regular'))    
        
    # 弱氢键供体（疏水碳-氢）    
    if hydrophobic_atoms:    
        for carbon in hydrophobic_atoms:    
            for adj_atom in pybel.ob.OBAtomAtomIter(carbon.atom.OBAtom):    
                if adj_atom.GetAtomicNum() == 1:  # 氢原子    
                    donors.append(data(d=carbon, h=pybel.Atom(adj_atom), type='weak'))    
        
    return donors    
  
class RingInfo:    
    """芳香环信息类 - 兼容 intra_pro_plip.py"""    
    def __init__(self, atoms, center, normal, ring_type='aromatic'):    
        self.atoms = atoms  # AtomInfo 对象列表    
        self.center = center    
        self.normal = normal    
        self.type = ring_type    
  
def find_rings(molecule):    
    """识别芳香环 - 返回 RingInfo 对象列表，兼容 intra_pro_plip.py"""    
    rings = []    
        
    ring_candidates = molecule.OBMol.GetSSSR()    
        
    for ring in ring_candidates:    
        ring_atoms = []    
        for atom in molecule.atoms:    
            if ring.IsMember(atom.OBAtom):    
                ring_atoms.append(AtomInfo(atom))    
            
        ring_atoms = sorted(ring_atoms, key=lambda x: x.idx)    
            
        if 4 < len(ring_atoms) <= 6:    
            if ring.IsAromatic():    
                ring_coords = [atom.coords for atom in ring_atoms]    
                center = np.mean(ring_coords, axis=0)    
                    
                if len(ring_atoms) >= 3:    
                    v1 = vector(ring_coords[0], ring_coords[2])    
                    v2 = vector(ring_coords[4 if len(ring_atoms) > 4 else 1], ring_coords[0])    
                    normal = normalize_vector(np.cross(v1, v2))    
                else:    
                    normal = np.array([0, 0, 1])    
                    
                ring_obj = RingInfo(ring_atoms, center, normal)    
                rings.append(ring_obj)    
        
    return rings    
  
def find_charged_groups(molecule):    
    """识别带电基团 - 返回 namedtuple 对象列表，兼容 intra_pro_plip.py"""    
    data = namedtuple('charge', 'atoms type center')    
    charged_groups = []    
        
    # 正电荷原子组    
    positive_atoms = []    
    negative_atoms = []    
        
    for atom in molecule.atoms:    
        if atom.formalcharge > 0:    
            positive_atoms.append(AtomInfo(atom))    
        elif atom.formalcharge < 0:    
            negative_atoms.append(AtomInfo(atom))    
            
        # 四价氮（季铵）    
        if atom.atomicnum == 7:    
            neighbors = list(pybel.ob.OBAtomAtomIter(atom.OBAtom))    
            if len(neighbors) == 4:    
                positive_atoms.append(AtomInfo(atom))    
            
        # 羧基氧    
        elif atom.atomicnum == 8:    
            neighbors = list(pybel.ob.OBAtomAtomIter(atom.OBAtom))    
            for neighbor in neighbors:    
                if neighbor.GetAtomicNum() == 6:    
                    carbon_neighbors = list(pybel.ob.OBAtomAtomIter(neighbor))    
                    oxygen_count = sum(1 for n in carbon_neighbors if n.GetAtomicNum() == 8)    
                    if oxygen_count >= 2:    
                        negative_atoms.append(AtomInfo(atom))    
                        break    
      
    # 构建带电基团对象    
    if positive_atoms:    
        center = np.mean([atom.coords for atom in positive_atoms], axis=0)    
        charged_groups.append(data(atoms=positive_atoms, type='positive', center=center))    
          
    if negative_atoms:    
        center = np.mean([atom.coords for atom in negative_atoms], axis=0)    
        charged_groups.append(data(atoms=negative_atoms, type='negative', center=center))    
        
    return charged_groups    
  
def find_halogen_acceptors(molecule):    
    """识别卤键受体 - 返回 namedtuple 对象列表，兼容 intra_pro_plip.py"""    
    data = namedtuple('hal_acceptor', 'o y')    
    acceptors = []    
        
    for atom in molecule.atoms:    
        if atom.atomicnum in [8, 7, 16]:  # O, N, S    
            neighbors = []    
            for neighbor in pybel.ob.OBAtomAtomIter(atom.OBAtom):    
                if neighbor.GetAtomicNum() in [6, 7, 15, 16]:  # C, N, P, S    
                    neighbors.append(pybel.Atom(neighbor))    
                
            if len(neighbors) >= 1:  # 至少有一个邻接原子    
                acceptors.append(data(o=AtomInfo(atom), y=neighbors[0]))    
        
    return acceptors    
  
def find_halogen_donors(molecule):    
    """识别卤键供体 - 返回 namedtuple 对象列表，兼容 intra_pro_plip.py"""    
    data = namedtuple('hal_donor', 'x c')    
    donors = []    
        
    for atom in molecule.atoms:    
        if atom.atomicnum in [9, 17, 35, 53]:  # F, Cl, Br, I    
            for neighbor in pybel.ob.OBAtomAtomIter(atom.OBAtom):    
                if neighbor.GetAtomicNum() == 6:  # 连接到碳原子    
                    donors.append(data(x=AtomInfo(atom), c=pybel.Atom(neighbor)))    
                    break    
        
    return donors    
  
def find_closest_atom_by_coord(coord: np.ndarray, molecule) -> Optional:     # type: ignore
    """根据坐标找到最接近的原子"""    
    min_dist = float('inf')    
    closest_atom = None    
        
    for atom in molecule.atoms:    
        atom_coord = np.array([atom.coords[0], atom.coords[1], atom.coords[2]])    
        dist = np.linalg.norm(coord - atom_coord)    
        if dist < min_dist:    
            min_dist = dist    
            closest_atom = atom    
        
    return closest_atom    
  
class InteractionAnalyzer:    
    """相互作用分析器 - 使用 intra_pro_plip.py 的精细检测函数"""    
        
    def __init__(self):    
        self.config = Config()  
        self.molecule = None  
        # 预计算的功能基团  
        self.hydrophobic_atoms = None  
        self.hba_atoms = None  
        self.hbd_atoms = None  
        self.rings = None  
        self.charged_groups = None  
        self.hal_acceptors = None  
        self.hal_donors = None  
      
    def set_molecule(self, molecule):  
        """设置分子并预计算所有功能基团"""  
        self.molecule = molecule  
        self.hydrophobic_atoms = find_hydrophobic_atoms(molecule)  
        self.hba_atoms = find_hba(molecule)  
        self.hbd_atoms = find_hbd(molecule, self.hydrophobic_atoms)  
        self.rings = find_rings(molecule)  
        self.charged_groups = find_charged_groups(molecule)  
        self.hal_acceptors = find_halogen_acceptors(molecule)  
        self.hal_donors = find_halogen_donors(molecule)  
        
    def analyze_atom_pair(self, atom1, atom2, distance: float) -> Optional[Dict]:    
        """分析原子对之间的相互作用 - 使用精细检测函数"""    
        if not self.molecule:  
            # 如果没有设置分子，回退到简化检测  
            return self._analyze_atom_pair_simple(atom1, atom2, distance)  
          
        interaction_types = []  
          
        # 转换为 AtomInfo 对象  
        atom1_info = AtomInfo(atom1)  
        atom2_info = AtomInfo(atom2)
        if self.hba_atoms and self.hbd_atoms:    
            atom1_acceptors = [acc for acc in self.hba_atoms if acc.idx == atom1.idx]    
            atom2_acceptors = [acc for acc in self.hba_atoms if acc.idx == atom2.idx]    
            atom1_donors = [don for don in self.hbd_atoms if don.d.idx == atom1.idx]    
            atom2_donors = [don for don in self.hbd_atoms if don.d.idx == atom2.idx]  

            # 检测氢键 - 使用精细的 hbonds 函数  
            if atom1_acceptors and atom2_donors:  
                hbond_results = hbonds(atom1_acceptors, atom2_donors)  
                if hbond_results:  
                    interaction_types.append('hydrogen_bond')  
            elif atom2_acceptors and atom1_donors:  
                hbond_results = hbonds(atom2_acceptors, atom1_donors)  
                if hbond_results:  
                    interaction_types.append('hydrogen_bond')  

        # 2. 检测疏水相互作用 - 使用精细的 hydrophobic_interactions 函数  
        if self.hydrophobic_atoms:  
            atom1_hydrophobic = [h for h in self.hydrophobic_atoms if h.idx == atom1.idx]  
            atom2_hydrophobic = [h for h in self.hydrophobic_atoms if h.idx == atom2.idx]  

            if atom1_hydrophobic and atom2_hydrophobic:  
                hydrophobic_results = hydrophobic_interactions(atom1_hydrophobic, atom2_hydrophobic)  
                if hydrophobic_results:  
                    interaction_types.append('hydrophobic')  

        # 3. 检测卤键 - 使用精细的 halogen_bonds 函数  
        if self.hal_acceptors and self.hal_donors:  
            atom1_hal_acc = [acc for acc in self.hal_acceptors if acc.o.idx == atom1.idx]  
            atom2_hal_acc = [acc for acc in self.hal_acceptors if acc.o.idx == atom2.idx]  
            atom1_hal_don = [don for don in self.hal_donors if don.x.idx == atom1.idx]  
            atom2_hal_don = [don for don in self.hal_donors if don.x.idx == atom2.idx]  

            if atom1_hal_acc and atom2_hal_don:  
                halogen_results = halogen_bonds(atom1_hal_acc, atom2_hal_don)  
                if halogen_results:  
                    interaction_types.append('halogen_bond')  
            elif atom2_hal_acc and atom1_hal_don:  
                halogen_results = halogen_bonds(atom2_hal_acc, atom1_hal_don)  
                if halogen_results:  
                    interaction_types.append('halogen_bond')  

        # 4. 检测盐桥 - 使用精细的 saltbridge 函数  
        if self.charged_groups:  
            pos_charged = [g for g in self.charged_groups if g.type == 'positive']  
            neg_charged = [g for g in self.charged_groups if g.type == 'negative']  

            # 检查原子是否属于带电基团  
            atom1_pos = [g for g in pos_charged if any(a.idx == atom1.idx for a in g.atoms)]  
            atom1_neg = [g for g in neg_charged if any(a.idx == atom1.idx for a in g.atoms)]  
            atom2_pos = [g for g in pos_charged if any(a.idx == atom2.idx for a in g.atoms)]  
            atom2_neg = [g for g in neg_charged if any(a.idx == atom2.idx for a in g.atoms)]  

            if (atom1_pos and atom2_neg) or (atom1_neg and atom2_pos):  
                # 使用相关的带电基团进行盐桥检测  
                relevant_pos = atom1_pos if atom1_pos else atom2_pos  
                relevant_neg = atom1_neg if atom1_neg else atom2_neg  
                saltbridge_results = saltbridge(relevant_pos, relevant_neg)  
                if saltbridge_results:  
                    interaction_types.append('salt_bridge')  

        return {  
            'interaction_types': interaction_types,  
            'distance': distance  
        } if interaction_types else None

===== intra_pro_plip.py =====
#!/usr/bin/env python3  
"""  
基于PLIP和OpenBabel的非共价相互作用类型识别脚本  
用于分析蛋白质内部原子对的相互作用类型  
"""  
  
import itertools  
import numpy as np  
from collections import namedtuple  
from openbabel import pybel  
from openbabel.openbabel import OBAtomAtomIter  
  
# 配置参数 (基于PLIP的默认阈值)  
class Config:  
    MIN_DIST = 0.5  
    HYDROPH_DIST_MAX = 4.0  
    HBOND_DIST_MAX = 4.0  
    HBOND_DON_ANGLE_MIN = 100  
    PISTACK_DIST_MAX = 5.5  
    PISTACK_ANG_DEV = 30  
    PISTACK_OFFSET_MAX = 2.0  
    PICATION_DIST_MAX = 6.0  
    SALTBRIDGE_DIST_MAX = 5.5  
    HALOGEN_DIST_MAX = 4.0  
    HALOGEN_ACC_ANGLE = 120  
    HALOGEN_DON_ANGLE = 165  
    HALOGEN_ANGLE_DEV = 30  
    AROMATIC_PLANARITY = 5.0  
  
config = Config()  
  
def euclidean3d(coord1, coord2):  
    """计算两点间的欧几里得距离"""  
    return np.sqrt(sum([(coord1[i] - coord2[i])**2 for i in range(3)]))  
  
def vector(coord1, coord2):  
    """计算从coord1到coord2的向量"""  
    return np.array([coord2[i] - coord1[i] for i in range(3)])  
  
def vecangle(vec1, vec2):  
    """计算两个向量间的夹角(度)"""  
    cos_angle = np.dot(vec1, vec2) / (np.linalg.norm(vec1) * np.linalg.norm(vec2))  
    cos_angle = np.clip(cos_angle, -1.0, 1.0)  
    return np.degrees(np.arccos(cos_angle))  
  
def normalize_vector(v):  
    """向量归一化"""  
    norm = np.linalg.norm(v)  
    if norm == 0:  
        return v  
    return v / norm  
  
def projection(normal, center, point):  
    """将点投影到由法向量和中心定义的平面上"""  
    v = np.array(point) - np.array(center)  
    proj_length = np.dot(v, normal) / np.dot(normal, normal)  
    return np.array(point) - proj_length * np.array(normal)  
  
def centroid(coords):  
    """计算坐标的质心"""  
    return np.mean(coords, axis=0)  
  
def ring_is_planar(ring, atoms):  
    """检查环是否平面，基于PLIP的实现""" [1] 
    if len(atoms) < 4:  
        return True  
      
    # 计算每个原子到其邻居的法向量  
    normals = []  
    for i in range(len(atoms)):  
        prev_atom = atoms[i-1]  
        curr_atom = atoms[i]  
        next_atom = atoms[(i+1) % len(atoms)]  
          
        v1 = vector(curr_atom.coords, prev_atom.coords)  
        v2 = vector(curr_atom.coords, next_atom.coords)  
        normal = np.cross(v1, v2)  
        if np.linalg.norm(normal) > 0:  
            normals.append(normalize_vector(normal))  
      
    if len(normals) < 2:  
        return True  
      
    # 检查所有法向量之间的角度  
    for i in range(len(normals)):  
        for j in range(i+1, len(normals)):  
            angle = vecangle(normals[i], normals[j])  
            if angle > config.AROMATIC_PLANARITY and (180 - angle) > config.AROMATIC_PLANARITY:  
                return False  
    return True  
  
class AtomInfo:  
    """原子信息类，包装OpenBabel原子"""  
    def __init__(self, pybel_atom, idx=None):  
        self.atom = pybel_atom  
        self.idx = idx if idx is not None else pybel_atom.idx  
        self.coords = pybel_atom.coords  
        self.atomicnum = pybel_atom.atomicnum  
        self.type = pybel_atom.type  
        self.OBAtom = pybel_atom.OBAtom  
  
class RingInfo:  
    """芳香环信息类"""  
    def __init__(self, atoms, center, normal, ring_type='aromatic'):  
        self.atoms = atoms  
        self.center = center  
        self.normal = normal  
        self.type = ring_type  
  
def find_hydrophobic_atoms(molecule):  
    """识别疏水原子 - 基于PLIP的hydrophobic_atoms方法""" [2]   
    hydrophobic_atoms = []  
      
    for atom in molecule.atoms:  
        # 只考虑碳原子  
        if atom.atomicnum == 6:  
            # 检查邻居原子是否只有碳和氢  
            neighbor_nums = set()  
            for neighbor in pybel.ob.OBAtomAtomIter(atom.OBAtom):  
                neighbor_nums.add(neighbor.GetAtomicNum())  
              
            # 如果邻居只有碳(6)和氢(1)，则为疏水原子  
            if neighbor_nums.issubset({1, 6}):  
                hydrophobic_atoms.append(AtomInfo(atom))  
      
    return hydrophobic_atoms  
  
def find_hba(molecule):  
    """识别氢键受体 - 基于PLIP的find_hba方法""" [3] 
    acceptors = []  
      
    for atom in molecule.atoms:  
        # 排除卤素原子  
        if atom.atomicnum not in [9, 17, 35, 53]:  
            if atom.OBAtom.IsHbondAcceptor():  
                acceptors.append(AtomInfo(atom))  
      
    return acceptors  
  
def find_hbd(molecule, hydrophobic_atoms=None):  
    """识别氢键供体 - 基于PLIP的find_hbd方法""" [4]   
    data = namedtuple('hbonddonor', 'd h type')  
    donors = []  
      
    # 强氢键供体  
    for atom in molecule.atoms:  
        if atom.OBAtom.IsHbondDonor():  
            for adj_atom in pybel.ob.OBAtomAtomIter(atom.OBAtom):  
                if adj_atom.IsHbondDonorH():  
                    donors.append(data(d=AtomInfo(atom), h=pybel.Atom(adj_atom), type='regular'))  
      
    # 弱氢键供体（疏水碳-氢）  
    if hydrophobic_atoms:  
        for carbon in hydrophobic_atoms:  
            for adj_atom in pybel.ob.OBAtomAtomIter(carbon.atom.OBAtom):  
                if adj_atom.GetAtomicNum() == 1:  # 氢原子  
                    donors.append(data(d=carbon, h=pybel.Atom(adj_atom), type='weak'))  
      
    return donors  
  
def find_rings(molecule):  
    """识别芳香环 - 基于PLIP的find_rings方法""" [5]   
    rings = []  
    aromatic_amino = ['TYR', 'TRP', 'HIS', 'PHE']  
      
    ring_candidates = molecule.OBMol.GetSSSR()  
      
    for ring in ring_candidates:  
        ring_atoms = []  
        for atom in molecule.atoms:  
            if ring.IsMember(atom.OBAtom):  
                ring_atoms.append(AtomInfo(atom))  
          
        ring_atoms = sorted(ring_atoms, key=lambda x: x.idx)  
          
        if 4 < len(ring_atoms) <= 6:  
            # 检查是否为芳香环  
            if ring.IsAromatic() or ring_is_planar(ring, ring_atoms):  
                # 计算环中心和法向量  
                ring_coords = [atom.coords for atom in ring_atoms]  
                center = centroid(ring_coords)  
                  
                # 使用三个原子计算法向量  
                if len(ring_atoms) >= 3:  
                    v1 = vector(ring_coords[0], ring_coords[2])  
                    v2 = vector(ring_coords[4 if len(ring_atoms) > 4 else 1], ring_coords[0])  
                    normal = normalize_vector(np.cross(v1, v2))  
                      
                    ring_info = RingInfo(ring_atoms, center, normal, f'{len(ring_atoms)}-membered')  
                    rings.append(ring_info)  
      
    return rings  
  
def find_charged_groups(molecule):  
    """识别带电基团 - 基于PLIP的find_charged方法""" [6]   
    data = namedtuple('charge', 'atoms type center')  
    charged_groups = []  
      
    # 遍历所有残基  
    for res in pybel.ob.OBResidueIter(molecule.OBMol):  
        contributing_atoms = []  
          
        # 正电荷：精氨酸、组氨酸、赖氨酸  
        if res.GetName() in ('ARG', 'HIS', 'LYS'):  
            for atom in pybel.ob.OBResidueAtomIter(res):  
                if atom.GetType().startswith('N') and res.GetAtomProperty(atom, 8):  # 侧链原子  
                    contributing_atoms.append(pybel.Atom(atom))  
              
            if contributing_atoms:  
                center = centroid([atom.coords for atom in contributing_atoms])  
                charged_groups.append(data(atoms=contributing_atoms, type='positive', center=center))  
          
        # 负电荷：天冬氨酸、谷氨酸  
        elif res.GetName() in ('GLU', 'ASP'):  
            for atom in pybel.ob.OBResidueAtomIter(res):  
                if atom.GetType().startswith('O') and res.GetAtomProperty(atom, 8):  # 侧链原子  
                    contributing_atoms.append(pybel.Atom(atom))  
              
            if contributing_atoms:  
                center = centroid([atom.coords for atom in contributing_atoms])  
                charged_groups.append(data(atoms=contributing_atoms, type='negative', center=center))  
      
    return charged_groups  
  
def find_halogen_acceptors(molecule):  
    """识别卤键受体 - 基于PLIP的find_hal方法""" [7] 
    data = namedtuple('hal_acceptor', 'o y')  
    acceptors = []  
      
    for atom in molecule.atoms:  
        # 氧、氮、硫原子  
        if atom.atomicnum in [8, 7, 16]:  
            neighbors = []  
            for neighbor in pybel.ob.OBAtomAtomIter(atom.OBAtom):  
                if neighbor.GetAtomicNum() in [6, 7, 15, 16]:  # C, N, P, S  
                    neighbors.append(pybel.Atom(neighbor))  
              
            if len(neighbors) == 1:  # 只有一个邻接原子  
                acceptors.append(data(o=AtomInfo(atom), y=neighbors[0]))  
      
    return acceptors  
  
def find_halogen_donors(molecule):  
    """识别卤键供体"""  
    data = namedtuple('hal_donor', 'x c')  
    donors = []  
      
    for atom in molecule.atoms:  
        # 卤素原子  
        if atom.atomicnum in [9, 17, 35, 53]:  # F, Cl, Br, I  
            for neighbor in pybel.ob.OBAtomAtomIter(atom.OBAtom):  
                if neighbor.GetAtomicNum() == 6:  # 连接到碳原子  
                    donors.append(data(x=AtomInfo(atom), c=pybel.Atom(neighbor)))  
                    break  
      
    return donors  
  
# 主要检测函数的完整实现  
  
def hydrophobic_interactions(atom_set_a, atom_set_b):  
    """检测疏水相互作用 - 基于PLIP的hydrophobic_interactions函数""" [8]   
    data = namedtuple('hydroph_interaction', 'atom1 atom2 distance type')  
    pairings = []  
      
    for a, b in itertools.product(atom_set_a, atom_set_b):  
        if a.idx == b.idx:  
            continue  
        distance = euclidean3d(a.coords, b.coords)  
        if config.MIN_DIST < distance < config.HYDROPH_DIST_MAX:  
            contact = data(atom1=a, atom2=b, distance=distance, type='hydrophobic')  
            pairings.append(contact)  
      
    return pairings  


def hbonds(acceptors, donors):  
    """检测氢键 - 基于PLIP的hbonds函数"""  
    data = namedtuple('hbond', 'acceptor donor hydrogen distance_ah distance_ad angle type')  
    pairings = []  
      
    for acc, don in itertools.product(acceptors, donors):  
        # 计算供体-受体距离  
        dist_ad = euclidean3d(acc.coords, don.d.coords)  
        if not config.MIN_DIST < dist_ad < config.HBOND_DIST_MAX:  
            continue  
          
        # 计算氢-受体距离  
        dist_ah = euclidean3d(acc.coords, don.h.coords)  
          
        # 计算供体角度 D-H...A  
        vec1 = vector(don.h.coords, don.d.coords)  
        vec2 = vector(don.h.coords, acc.coords)  
        angle = vecangle(vec1, vec2)  
          
        if angle > config.HBOND_DON_ANGLE_MIN:  
            contact = data(acceptor=acc, donor=don.d, hydrogen=don.h,  
                         distance_ah=dist_ah, distance_ad=dist_ad,   
                         angle=angle, type='hydrogen_bond')  
            pairings.append(contact)  
      
    return pairings

def pistacking(rings_a, rings_b):  
    """检测π-π堆积"""  
    data = namedtuple('pistacking', 'ring1 ring2 distance angle offset type')  
    pairings = []  
      
    for ring1, ring2 in itertools.product(rings_a, rings_b):  
        distance = euclidean3d(ring1.center, ring2.center)  
        if config.MIN_DIST < distance < config.PISTACK_DIST_MAX:  
            # 计算环平面间的角度  
            angle = vecangle(ring1.normal, ring2.normal)  
            angle = min(angle, 180 - angle)  # 取较小角度  
              
            # 计算偏移  
            proj1 = projection(ring2.normal, ring2.center, ring1.center)  
            proj2 = projection(ring1.normal, ring1.center, ring2.center)  
            offset = min(euclidean3d(proj1, ring2.center), euclidean3d(proj2, ring1.center))  
              
            # 判断堆积类型  
            if angle < config.PISTACK_ANG_DEV and offset < config.PISTACK_OFFSET_MAX:  
                stack_type = 'parallel'  
                contact = data(ring1=ring1, ring2=ring2, distance=distance,  
                             angle=angle, offset=offset, type=f'pi_stacking_{stack_type}')  
                pairings.append(contact)  
            elif abs(90 - angle) < config.PISTACK_ANG_DEV and offset < config.PISTACK_OFFSET_MAX:  
                stack_type = 'perpendicular'  
                contact = data(ring1=ring1, ring2=ring2, distance=distance,  
                             angle=angle, offset=offset, type=f'pi_stacking_{stack_type}')  
                pairings.append(contact)  
      
    return pairings  
  
def saltbridge(pos_charged, neg_charged):  
    """检测盐桥"""  
    data = namedtuple('saltbridge', 'positive negative distance type')  
    pairings = []  
      
    for pos, neg in itertools.product(pos_charged, neg_charged):  
        distance = euclidean3d(pos.center, neg.center)  
        if config.MIN_DIST < distance < config.SALTBRIDGE_DIST_MAX:  
            contact = data(positive=pos, negative=neg, distance=distance, type='salt_bridge')  
            pairings.append(contact)  
      
    return pairings  
  
def pication(rings, charged_groups):  
    """检测π-阳离子相互作用"""  
    data = namedtuple('pication', 'ring charge distance offset type')  
    pairings = []  
      
    for ring, charge in itertools.product(rings, charged_groups):  
        distance = euclidean3d(ring.center, charge.center)  
        if config.MIN_DIST < distance < config.PICATION_DIST_MAX:  
            # 计算偏移  
            proj = projection(ring.normal, ring.center, charge.center)  
            offset = euclidean3d(proj, ring.center)  
              
            if offset < config.PISTACK_OFFSET_MAX:  
                contact = data(ring=ring, charge=charge, distance=distance,  
                             offset=offset, type='pi_cation')  
                pairings.append(contact)  
      
    return pairings  
  
def halogen_bonds(acceptors, donors):  
    """检测卤键"""  
    data = namedtuple('halogen_bond', 'acceptor donor distance don_angle acc_angle type')  
    pairings = []  
      
    for acc, don in itertools.product(acceptors, donors):  
        distance = euclidean3d(acc.o.coords, don.x.coords)  
        if config.MIN_DIST < distance < config.HALOGEN_DIST_MAX:  
            # 计算角度  
            vec1 = vector(acc.o.coords, acc.y.coords)  
            vec2 = vector(acc.o.coords, don.x.coords)  
            acc_angle = vecangle(vec1, vec2)  
              
            vec3 = vector(don.x.coords, acc.o.coords)  
            vec4 = vector(don.x.coords, don.c.coords)  
            don_angle = vecangle(vec3, vec4)  
              
            # 检查角度条件  
            if (config.HALOGEN_ACC_ANGLE - config.HALOGEN_ANGLE_DEV < acc_angle <   
                config.HALOGEN_ACC_ANGLE + config.HALOGEN_ANGLE_DEV and  
                config.HALOGEN_DON_ANGLE - config.HALOGEN_ANGLE_DEV < don_angle <   
                config.HALOGEN_DON_ANGLE + config.HALOGEN_ANGLE_DEV):  
                  
                contact = data(acceptor=acc, donor=don, distance=distance,  
                             don_angle=don_angle, acc_angle=acc_angle, type='halogen_bond')  
                pairings.append(contact)  
      
    return pairings

class InteractionAnalyzer:  
    """相互作用分析器主类 - 使用精细的PLIP检测函数"""  
      
    def __init__(self):  
        self.interactions = []  
        self.molecule = None  
        # 预计算的功能基团  
        self.hydrophobic_atoms = None  
        self.hba_atoms = None  
        self.hbd_atoms = None  
        self.rings = None  
        self.charged_groups = None  
        self.hal_acceptors = None  
        self.hal_donors = None  
      
    def set_molecule(self, molecule):  
        """设置分子并预计算所有功能基团"""  
        self.molecule = molecule  
        self.hydrophobic_atoms = find_hydrophobic_atoms(molecule)  
        self.hba_atoms = find_hba(molecule)  
        self.hbd_atoms = find_hbd(molecule, self.hydrophobic_atoms)  
        self.rings = find_rings(molecule)  
        self.charged_groups = find_charged_groups(molecule)  
        self.hal_acceptors = find_halogen_acceptors(molecule)  
        self.hal_donors = find_halogen_donors(molecule)  
      
    def analyze_atom_pair(self, atom1, atom2, distance=None):  
        """分析单个原子对的相互作用类型 - 使用精细检测函数"""  
        if distance is None:  
            distance = euclidean3d(atom1.coords, atom2.coords)  

        if distance > 5.0:  # 超过5Å的不分析  
            return None  

        interaction_types = []  

        # 添加原子索引调试信息  
        # print(f"[DEBUG] 分析原子对: atom1.idx={atom1.idx}, atom2.idx={atom2.idx}, 距离={distance:.2f}Å")  

        # 1. 检测氢键 - 使用精细的hbonds函数  
        if self.hba_atoms and self.hbd_atoms:  
            atom1_acceptors = [acc for acc in self.hba_atoms if acc.idx == atom1.idx]  
            atom2_acceptors = [acc for acc in self.hba_atoms if acc.idx == atom2.idx]  
            atom1_donors = [don for don in self.hbd_atoms if don.d.idx == atom1.idx]  
            atom2_donors = [don for don in self.hbd_atoms if don.d.idx == atom2.idx]  

            # # 添加匹配调试信息  
            # print(f"[DEBUG] 氢键匹配: atom1_acceptors={len(atom1_acceptors)}, atom2_acceptors={len(atom2_acceptors)}")  
            # print(f"[DEBUG] 氢键匹配: atom1_donors={len(atom1_donors)}, atom2_donors={len(atom2_donors)}")  

            # 检测氢键  
            if atom1_acceptors and atom2_donors:  
                # print(f"[DEBUG] 尝试检测氢键: acceptor={atom1.idx} -> donor={atom2.idx}")  
                hbond_results = hbonds(atom1_acceptors, atom2_donors)  
                if hbond_results:  
                    # print(f"[DEBUG] 检测到氢键: {len(hbond_results)} 个")  
                    interaction_types.append('hydrogen_bond')  
            elif atom2_acceptors and atom1_donors:  
                # print(f"[DEBUG] 尝试检测氢键: acceptor={atom2.idx} -> donor={atom1.idx}")  
                hbond_results = hbonds(atom2_acceptors, atom1_donors)  
                if hbond_results:  
                    # print(f"[DEBUG] 检测到氢键: {len(hbond_results)} 个")  
                    interaction_types.append('hydrogen_bond')  
            else:  
                pass

        # 2. 检测疏水相互作用 - 使用精细的hydrophobic_interactions函数  
        if self.hydrophobic_atoms:  
            atom1_hydrophobic = [h for h in self.hydrophobic_atoms if h.idx == atom1.idx]  
            atom2_hydrophobic = [h for h in self.hydrophobic_atoms if h.idx == atom2.idx]  
              
            if atom1_hydrophobic and atom2_hydrophobic:  
                hydrophobic_results = hydrophobic_interactions(atom1_hydrophobic, atom2_hydrophobic)  
                if hydrophobic_results:  
                    interaction_types.append('hydrophobic')  
          
        # 3. 检测卤键 - 使用精细的halogen_bonds函数  
        if self.hal_acceptors and self.hal_donors:  
            atom1_hal_acc = [acc for acc in self.hal_acceptors if acc.o.idx == atom1.idx]  
            atom2_hal_acc = [acc for acc in self.hal_acceptors if acc.o.idx == atom2.idx]  
            atom1_hal_don = [don for don in self.hal_donors if don.x.idx == atom1.idx]  
            atom2_hal_don = [don for don in self.hal_donors if don.x.idx == atom2.idx]  
              
            if atom1_hal_acc and atom2_hal_don:  
                halogen_results = halogen_bonds(atom1_hal_acc, atom2_hal_don)  
                if halogen_results:  
                    interaction_types.append('halogen_bond')  
            elif atom2_hal_acc and atom1_hal_don:  
                halogen_results = halogen_bonds(atom2_hal_acc, atom1_hal_don)  
                if halogen_results:  
                    interaction_types.append('halogen_bond')  
          
        # 4. 检测盐桥 - 使用精细的saltbridge函数  
        if self.charged_groups:  
            pos_charged = [g for g in self.charged_groups if g.type == 'positive']  
            neg_charged = [g for g in self.charged_groups if g.type == 'negative']  
              
            # 检查原子是否属于带电基团  
            atom1_pos = [g for g in pos_charged if any(a.idx == atom1.idx for a in g.atoms)]  
            atom1_neg = [g for g in neg_charged if any(a.idx == atom1.idx for a in g.atoms)]  
            atom2_pos = [g for g in pos_charged if any(a.idx == atom2.idx for a in g.atoms)]  
            atom2_neg = [g for g in neg_charged if any(a.idx == atom2.idx for a in g.atoms)]  
              
            if (atom1_pos and atom2_neg) or (atom1_neg and atom2_pos):  
                # 使用相关的带电基团进行盐桥检测  
                relevant_pos = atom1_pos if atom1_pos else atom2_pos  
                relevant_neg = atom1_neg if atom1_neg else atom2_neg  
                saltbridge_results = saltbridge(relevant_pos, relevant_neg)  
                if saltbridge_results:  
                    interaction_types.append('salt_bridge')  
          
        return {  
            'atom1': atom1,  
            'atom2': atom2,  
            'distance': distance,  
            'interaction_types': interaction_types  
        }  
      
    def analyze_molecule_interactions(self, molecule):  
        """分析整个分子的相互作用（包括π-π堆积和π-阳离子）- 使用精细检测函数"""  
        if not self.molecule:  
            self.set_molecule(molecule)  
          
        results = []  
          
        # 检测π-π堆积 - 使用精细的pistacking函数  
        if self.rings:  
            pi_stacks = pistacking(self.rings, self.rings)  
            for stack in pi_stacks:  
                results.append({  
                    'interaction_type': 'pi_stacking',  
                    'ring1': stack.ring1,  
                    'ring2': stack.ring2,  
                    'distance': stack.distance,  
                    'type': stack.type  
                })  
          
        # 检测π-阳离子相互作用 - 使用精细的pication函数  
        if self.rings and self.charged_groups:  
            pos_charged = [g for g in self.charged_groups if g.type == 'positive']  
            pi_cations = pication(self.rings, pos_charged)  
            for pication_int in pi_cations:  
                results.append({  
                    'interaction_type': 'pi_cation',  
                    'ring': pication_int.ring,  
                    'charge': pication_int.charge,  
                    'distance': pication_int.distance  
                })  
          
        return results
  
# 使用示例  
if __name__ == "__main__":  
    analyzer = InteractionAnalyzer()  
    print("完整的非共价相互作用分析脚本已准备就绪")  
    print("支持检测：疏水相互作用、氢键、盐桥、卤键、π-π堆积、π-阳离子相互作用")

